/*
 * generated by Xtext 2.17.0
 */
package dk.sdu.mdsd.serializer;

import com.google.inject.Inject;
import dk.sdu.mdsd.arduinoDSL.ArduinoDSLPackage;
import dk.sdu.mdsd.arduinoDSL.Assignment;
import dk.sdu.mdsd.arduinoDSL.Attribute;
import dk.sdu.mdsd.arduinoDSL.Component;
import dk.sdu.mdsd.arduinoDSL.ComponentBody;
import dk.sdu.mdsd.arduinoDSL.Condition;
import dk.sdu.mdsd.arduinoDSL.Delta;
import dk.sdu.mdsd.arduinoDSL.Div;
import dk.sdu.mdsd.arduinoDSL.Exp;
import dk.sdu.mdsd.arduinoDSL.Factor;
import dk.sdu.mdsd.arduinoDSL.Map;
import dk.sdu.mdsd.arduinoDSL.Minus;
import dk.sdu.mdsd.arduinoDSL.Mult;
import dk.sdu.mdsd.arduinoDSL.Node;
import dk.sdu.mdsd.arduinoDSL.NumberLiteral;
import dk.sdu.mdsd.arduinoDSL.Plus;
import dk.sdu.mdsd.arduinoDSL.Program;
import dk.sdu.mdsd.arduinoDSL.Range;
import dk.sdu.mdsd.arduinoDSL.Rate;
import dk.sdu.mdsd.arduinoDSL.Rule;
import dk.sdu.mdsd.arduinoDSL.RuleBody;
import dk.sdu.mdsd.arduinoDSL.Smoothing;
import dk.sdu.mdsd.arduinoDSL.State;
import dk.sdu.mdsd.services.ArduinoDSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ArduinoDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ArduinoDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ArduinoDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ArduinoDSLPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case ArduinoDSLPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ArduinoDSLPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case ArduinoDSLPackage.COMPONENT_BODY:
				sequence_ComponentBody(context, (ComponentBody) semanticObject); 
				return; 
			case ArduinoDSLPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case ArduinoDSLPackage.DELTA:
				sequence_Delta(context, (Delta) semanticObject); 
				return; 
			case ArduinoDSLPackage.DIV:
				sequence_ExpStrongOp(context, (Div) semanticObject); 
				return; 
			case ArduinoDSLPackage.EXP:
				sequence_Exp(context, (Exp) semanticObject); 
				return; 
			case ArduinoDSLPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case ArduinoDSLPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case ArduinoDSLPackage.MINUS:
				sequence_ExpWeakOp(context, (Minus) semanticObject); 
				return; 
			case ArduinoDSLPackage.MULT:
				sequence_ExpStrongOp(context, (Mult) semanticObject); 
				return; 
			case ArduinoDSLPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case ArduinoDSLPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case ArduinoDSLPackage.PLUS:
				sequence_ExpWeakOp(context, (Plus) semanticObject); 
				return; 
			case ArduinoDSLPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case ArduinoDSLPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case ArduinoDSLPackage.RATE:
				sequence_Rate(context, (Rate) semanticObject); 
				return; 
			case ArduinoDSLPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case ArduinoDSLPackage.RULE_BODY:
				sequence_RuleBody(context, (RuleBody) semanticObject); 
				return; 
			case ArduinoDSLPackage.SMOOTHING:
				sequence_Smoothing(context, (Smoothing) semanticObject); 
				return; 
			case ArduinoDSLPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (attribute=Attribute value=Exp)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.ASSIGNMENT__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.ASSIGNMENT__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAttributeAttributeParserRuleCall_0_0(), semanticObject.getAttribute());
		feeder.accept(grammarAccess.getAssignmentAccess().getValueExpParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Attribute
	 *     Exp.Exp_1_0 returns Attribute
	 *     Factor returns Attribute
	 *     Factor.Factor_1_0 returns Attribute
	 *     Value returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=[Node|ID] component=[Component|ID])
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.ATTRIBUTE__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.ATTRIBUTE__COMPONENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ArduinoDSLPackage.Literals.ATTRIBUTE__NAME, false));
		feeder.accept(grammarAccess.getAttributeAccess().getComponentComponentIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ArduinoDSLPackage.Literals.ATTRIBUTE__COMPONENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComponentBody returns ComponentBody
	 *
	 * Constraint:
	 *     (
	 *         io=IO 
	 *         type=TYPE 
	 *         pin=INT 
	 *         map=Map? 
	 *         rate=Rate? 
	 *         smoothing=Smoothing?
	 *     )
	 */
	protected void sequence_ComponentBody(ISerializationContext context, ComponentBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (name=ID properties=ComponentBody)
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.COMPONENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.COMPONENT__NAME));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.COMPONENT__PROPERTIES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.COMPONENT__PROPERTIES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getComponentAccess().getPropertiesComponentBodyParserRuleCall_1_0(), semanticObject.getProperties());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (left=Exp operator=BOOLEAN_OPERATOR right=Exp)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.CONDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.CONDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.CONDITION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.CONDITION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.CONDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.CONDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getLeftExpParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionAccess().getOperatorBOOLEAN_OPERATORTerminalRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getConditionAccess().getRightExpParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Delta
	 *     Exp.Exp_1_0 returns Delta
	 *     Factor returns Delta
	 *     Factor.Factor_1_0 returns Delta
	 *     Value returns Delta
	 *     Delta returns Delta
	 *
	 * Constraint:
	 *     attr=Attribute
	 */
	protected void sequence_Delta(ISerializationContext context, Delta semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.DELTA__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.DELTA__ATTR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeltaAccess().getAttrAttributeParserRuleCall_0_0(), semanticObject.getAttr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpStrongOp returns Div
	 *
	 * Constraint:
	 *     {Div}
	 */
	protected void sequence_ExpStrongOp(ISerializationContext context, Div semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpStrongOp returns Mult
	 *
	 * Constraint:
	 *     {Mult}
	 */
	protected void sequence_ExpStrongOp(ISerializationContext context, Mult semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpWeakOp returns Minus
	 *
	 * Constraint:
	 *     {Minus}
	 */
	protected void sequence_ExpWeakOp(ISerializationContext context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpWeakOp returns Plus
	 *
	 * Constraint:
	 *     {Plus}
	 */
	protected void sequence_ExpWeakOp(ISerializationContext context, Plus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Exp
	 *     Exp.Exp_1_0 returns Exp
	 *
	 * Constraint:
	 *     (left=Exp_Exp_1_0 operator=ExpWeakOp right=Factor)
	 */
	protected void sequence_Exp(ISerializationContext context, Exp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.EXP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.EXP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.EXP__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.EXP__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.EXP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.EXP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getExpLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getOperatorExpWeakOpParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpAccess().getRightFactorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Factor
	 *     Exp.Exp_1_0 returns Factor
	 *     Factor returns Factor
	 *     Factor.Factor_1_0 returns Factor
	 *
	 * Constraint:
	 *     (left=Factor_Factor_1_0 operator=ExpStrongOp right=Value)
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.FACTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.FACTOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.FACTOR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.FACTOR__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.FACTOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.FACTOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getFactorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getOperatorExpStrongOpParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getFactorAccess().getRightValueParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (in=Range out=Range)
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.MAP__IN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.MAP__IN));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.MAP__OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.MAP__OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapAccess().getInRangeParserRuleCall_1_0(), semanticObject.getIn());
		feeder.accept(grammarAccess.getMapAccess().getOutRangeParserRuleCall_3_0(), semanticObject.getOut());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (name=ID components+=Component+)
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns NumberLiteral
	 *     Exp.Exp_1_0 returns NumberLiteral
	 *     Factor returns NumberLiteral
	 *     Factor.Factor_1_0 returns NumberLiteral
	 *     Value returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     (float=DECIMAL | int=INT)
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (program+=Rule | program+=Node)+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (low=NUMBER high=NUMBER)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.RANGE__LOW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.RANGE__LOW));
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.RANGE__HIGH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.RANGE__HIGH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getLowNUMBERParserRuleCall_0_0(), semanticObject.getLow());
		feeder.accept(grammarAccess.getRangeAccess().getHighNUMBERParserRuleCall_2_0(), semanticObject.getHigh());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rate returns Rate
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Rate(ISerializationContext context, Rate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.RATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.RATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRateAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleBody returns RuleBody
	 *
	 * Constraint:
	 *     assignment+=Assignment+
	 */
	protected void sequence_RuleBody(ISerializationContext context, RuleBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     ((type='when' | type='once') condition=Condition body=RuleBody)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Smoothing returns Smoothing
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_Smoothing(ISerializationContext context, Smoothing semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoDSLPackage.Literals.SMOOTHING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoDSLPackage.Literals.SMOOTHING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSmoothingAccess().getValueNUMBERParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns State
	 *     Exp.Exp_1_0 returns State
	 *     Factor returns State
	 *     Factor.Factor_1_0 returns State
	 *     Value returns State
	 *     State returns State
	 *
	 * Constraint:
	 *     (value='on' | value='off')
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
